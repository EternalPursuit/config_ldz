# 1. 类的学习
## 1.1 类中类
在这种情况的编写时， 具体的操作是在头文件中，正常的编写声明，这包含了一些自定义的数据结构的声明，例如结构体，枚举类，等。 当然也可以包含一些 类中类，以及管理对象的 智能指针。

尤其是智能指针的使用，特别频繁。 因此一定要熟悉这类 编程思想。


至于类中类的定义来说：只需要声明即可，不需要详细声明，具体的声明是放在与之对应的.cpp文件中的，同时，在其下面还要写对应的实现，进而实现 声明和定义的分离。

## 1.2. 关于构造函数的学习
构造函数的设计 一定要小心，因为构造函数的种类很多，例如：复制构造函数，复制运算符重载，移动构造函数，移动构造运算符重载等，这些都需要去关心，因为系统会在缺失的情况下自动提供这些构造函数。

但是如果不处理的话， 在一些场景下，错误的使用就会导致 类的实例化对象  错误使用，进而引发bug，导致程序出错。

一般情况下：这些函数都是需要=delete进行处理的。不过重载运算符不能使用delete，这个需要确认一下。


对于std::move运算符来说：如果使用了之后，原始对象的存储管理是否全部交给 新的对象，释放对象是否会造成指针泄露。

对于一个vector对象，他的front，back都返回什么，是一个指针？我原本以为是一个元素，或者说对象之类的。

对于不同运算符的重载来说：他们的固定返回对象是？ 例如：operator=来说，他的固定返回就是return *this， 同时他的返回值类型是：这个类的类型


## 1.3 关于虚类的学习

一般来说虚类的掌握是很关键的。，这主要是因为虚类提供了一个统一地接口，使得我们能够利用这个接口调用不同的继承子类，至于为什么能够调用的原因，虚函数给出了很明确的理由，由于虚函数的存在，导致每一个类都存了一个虚函数表，表记录了类指针调用函数的实际地址，而不是基类的地址。因此，在类的对象创建的时候，对象中保存了一个指向类虚函数表的指针。通过这个指针(基类)，基类指针能够调用到真正的函数。实现了相同接口，调用不同对象的函数的结果。这是一种非常有用的实现。


还需要知道关于 析构函数的 虚化。 析构函数在类中没有虚构函数的时候，是否仍然需要虚函数。





# 2. 容器的学习

对于一个map类型的对象来说：如果使用try_emplace，那么他的返回值是什么类型？为什么可以ret.second？


在使用一个容器的时候，我们一般是需要初始化一个容器，然后使用reserve来为他扩容，这样做的目的或者好处是？在使用的时候，我们通常需要配合一系列的函数：insert(buffer.end(),new_buffer.begin(),new_buffer.end())

同时，在实际的开发过程中，对于容器的swap函数使用也很频繁。这个的场景一般在函数的传入参数处理中，通过在函数内部创建一个容器对象，然后利用初始化构造函数进行赋值，或者一些其他的赋值操作，将函数内部创建的临时对象进行填充后，形成了最终输出的内容，然后再使用(一般传出参数都是引用传进来的)：所以这时候只需要简单的dst.swap(out)就行了。



## 关于容器大小的比较学习
一般来说都是直接使用size函数来获取容器的元素个数，但是由于在涉及内存的时候，需要的是跟不同类型的数据进行比较，因此，这时候就需要用size()*sizeof(对应的类型名：uint8_t)

有时候容器的resize同样重要，这个道理和reserve函数的道理是一样的。 需要开辟足够的空间来存储相应的数据。

至于size的大小，一般来说都是需要经过计算传入的：例如：max_num*sizeof(对象或者类型)







# 3. 一些非类的知识学习

## 3.1 命名空间的学习
一般来说都是对应的文件夹有对应的命名空间，但是在开发的过程中，一些功能需要统一地放在一起，因此有时候会有统一地命名空间。

## 3.2. 宏定义的使用：

#define HAHA(x) (void)(x)

#define IF_HAHA(x)  \
    do {            \
        if ((cond)) {              \
            HAHAH("you are wrong!")  \
        }      
    } while(0) 


## 3.3 constexpr int hah - 73; 
还是需要加强constexpr表达式的学习，然后能够使用起来。

typedef struct {
    int dfa;
    uint32_t radius;
} hahah;

然后就可以使用这个hahah的结构体了，这就是类型名。


## 3.4. 还需要知道关于数据类型的知识
有时候会忽略这种知识，其实这种知识在真正的编程中是真正有用的。

需要知道关于uint32_t，uint这类知识。



# 4. 关于函数的学习

在函数的函数体设计中，有时候会有一种涉及就是预处理的设计：
这种情况下，一般都是通过
#ifdef 或者 #ifndef这类开始

然后是 符合条件需要执行的真正的函数体。

上面这种就是实现了一种 根据预设的条件进行编译的情况。



有时候需要写一些 匿名函数来实现一定的功能，这主要是因为这类函数的功能简短，使用的生命周期有限导致的。
因此这时候使用 匿名函数 非常适合， 在一些容器的操作中，这是非常常见的操作，特别是在一些传入仿函数对象的地方。




